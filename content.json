{"meta":{"title":"E.K 2.0","subtitle":"Product Owner & Coach & Developer 混合體","description":"科技 & 人文 & 啟發","author":"Edward kuo","url":"http://edwardkuo.github.io"},"pages":[{"title":"About","date":"2016-04-20T20:48:33.000Z","updated":"2016-06-09T16:20:53.000Z","comments":true,"path":"about/index.html","permalink":"http://edwardkuo.github.io/about/index.html","excerpt":"","text":"Coming Soon"},{"title":"整理個人愛用的Sublime外掛套件","date":"2016-01-20T20:48:33.000Z","updated":"2016-06-10T12:25:34.000Z","comments":true,"path":"sublime/Sublime.html","permalink":"http://edwardkuo.github.io/sublime/Sublime.html","excerpt":"","text":"因為工作需要，開始做一些Font-End的工作，雖然，Visuao Stduio已經非常好用，但是，就前端工程師來說用的比較多還是Sublime，Sublime好用這裡就不做介紹，我們知道它是一個輕量化的編輯軟體，很多功能都是你需要時候才透過Plugin方式來安裝，若是，你安裝Plug-in套件，這東西就跟筆記本沒啥兩樣，所以，外掛選用就變成是一件重要的東西。諷刺的是，若是外掛裝多，這東西也就龐大，當然效能也就變慢了，一個好的方式就是下載免安裝版本的sublime，依照在不同工作需求去產生不同的sublime執行資料夾，避免同一個sublime裝太多套件變慢了 紅框為可攜帶版本，也就是說套件裝好後，可以任意攜帶到其他電腦繼續使用，不需要重裝套件 要安裝套件時候，記得必須先安裝Package install panel套件，安裝方法可以參考 http://packagecontrol.io/installation 陸陸續續整理一些不錯的套件給大家使用，若是有好的套件也歡迎推薦給我 ChinesOpenConvert 主要是做繁體與簡體轉換，除了文字轉換，還會針對慣用語的轉換，慣用語轉換的準確度還算可以 SASS &amp; SCSS 要用SASS寫CSS的話，兩個語法在原本sublime是沒有支援，必須額外安裝。不過，可以依照自己愛用哪一種語法去開發，安裝其中一個就可以 Html-CSS-JS Prettify 支援HTML &amp; CSS &amp; JS排版的套件，透過它可以美化程式版型，在使用之前，電腦必須安裝Node.JS，它是基於Node.jS下的運作的套件未安裝前的格式美化後的樣式 sidebarenhancements 讓Sublime的側邊功能加強原本有的功能只有下面這樣，功能看起來少少的安裝完畢後，可以發現側邊欄位的功能變成很多了 ConvertToUTF8 預設sublime並不支援utf8，避免後續出現亂碼，這套件幾乎是必須安裝的 Emmet 讓我們可以快速產生Html Tag的套件，透過這套件可以簡化很多打字的力氣例如:你只要在空白頁面打入 ! + Tab，就會出現下面圖樣，Tag都幫你做好了又或是你要打槽狀的Html Tag，可以這樣打div&gt;p&gt;span + Tab，這語法其實不需死記，因為這語法其實就是跟撰寫CSS是相同的，只要會撰寫CSS就可以快速建立這樣結構 更多語法可以參考http://docs.emmet.io AutoFileName 當我們在使用一些Tag需要用到資料夾內的各個檔案路徑時候，會自動幫我們顯示出來這樣好處在於，可以快速找到我們要的檔案，也可以省掉打一些路徑的時間"}],"posts":[{"title":"C# 使用For和Foreach讀取Datatable每筆資料對照寫法","slug":"Net/2016-06-10-1","date":"2016-06-10T14:59:31.000Z","updated":"2016-06-10T14:30:37.000Z","comments":true,"path":"paper/2016/06/10/Net/2016-06-10-1/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/Net/2016-06-10-1/","excerpt":"","text":"早期各種程式語法針對迴圈寫法，總是用for來實作，這東西真是好用且還歷久不衰，不過，到了開始有Foreach之後，很多迴圈寫法都會改用Foreach實作，畢竟，Foreach算是好物之一。但是，因為長時間習慣用for語法，要一時改變還真不簡單，所以，趁現在趕快紀錄一下避免忘記 採用For迴圈方式讀Datatable，其中邏輯是要判斷不是第一筆要處理的相關邏輯程式12345678910111213141516171819202122232425for (int i = 0; i &lt; _dt.Rows.Count; i++)&#123; if (strReportID != _dt.Rows[i][&quot;s&quot;].ToString()) &#123; if (i != 0) &#123; dr[&quot;R&quot;] = sb.ToString(); dt.Rows.Add(dr); sb = new StringBuilder(); dr = dt.NewRow(); &#125; strReportID = _dt.Rows[i][&quot;s&quot;].ToString(); dr[&quot;ss&quot;] = _dt.Rows[i][&quot;ss&quot;].ToString(); sb.Append(_dt.Rows[i][&quot;Name&quot;] + &quot;&lt;br /&gt;&quot;); &#125; else &#123; sb.Append(_dt.Rows[i][&quot;Name&quot;] + &quot;&lt;br /&gt;&quot;); &#125;&#125;dr[&quot;R&quot;] = sb.ToString();dt.Rows.Add(dr); 2.用Foreach寫法後，原本判斷是否為第一筆的邏輯，就要改用boolen方式去判斷。且原本是 _dt.Rows[i]的方式就可以省略，改用Datarow物件代替12345678910111213141516171819202122232425bool bFirst = false;foreach (DataRow od in _dt.Rows)&#123; if (strReportID != od[&quot;s&quot;].ToString()) &#123; if(!bFirst) &#123; dr[&quot;R&quot;] = sb.ToString(); dt.Rows.Add(dr); sb = new StringBuilder(); dr = dt.NewRow(); bFirst = true; &#125; strReportID = od[&quot;s&quot;].ToString(); dr[&quot;ss&quot;] = od[&quot;ss&quot;].ToString(); sb.Append(od[&quot;Name&quot;] + &quot;&lt;br /&gt;&quot;); &#125; else &#123; sb.Append(od[&quot;Name&quot;] + &quot;&lt;br /&gt;&quot;); &#125; &#125;dr[&quot;R&quot;] = sb.ToString();dt.Rows.Add(dr);","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://edwardkuo.github.io/tags/C/"}]},{"title":"C# 無條件進位,無條件捨去及四捨五入寫法","slug":"Net/2016-06-10-2","date":"2016-06-10T14:59:31.000Z","updated":"2016-06-10T14:31:30.000Z","comments":true,"path":"paper/2016/06/10/Net/2016-06-10-2/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/Net/2016-06-10-2/","excerpt":"","text":"雖然程式很簡單，但是，一時要用還真的不知道要怎樣寫，畢竟現在一個程式開發者要記憶的東西太多，所以，不時時刻刻記憶一些東西還真的不行呢 無條件進位 123double s = 100;int result = 0;result = Convert.ToInt16(Math.Ceiling(s / 3)); 無條件捨去 123double s = 100;int result = 0;result =Convert.ToInt16( Math.Floor(s / 3)); 四捨五入使用Math.Round， Math.Round(計算值,小數點第幾位) 123double s = 110;double result = 0;result = Math.Round((s / 3), 2); 若是要呈現一般認知的四捨五入需加入第三個參數，MidpointRounding.AwayFromZer 1System.Math.Round(1.235 , 2, MidpointRounding.AwayFromZero) 參考來源：http://msdn.microsoft.com/zh-tw/library/ef48waz8(v=VS.100).aspx","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://edwardkuo.github.io/tags/C/"}]},{"title":"使用Linq的Join / right Join / Left Join","slug":"Net/2016-06-10","date":"2016-06-10T14:59:31.000Z","updated":"2016-06-10T14:28:30.000Z","comments":true,"path":"paper/2016/06/10/Net/2016-06-10/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/Net/2016-06-10/","excerpt":"","text":"用Join來做資料聯集，在T-SQL指令是常會用到的一種語法，不過，對於常寫SQL語法的人要轉換到Linq語法時，往往對於Join這語句的操作就常會感到比較陌生也不習慣要怎樣使用。因此，這邊簡單說明一下，要如何操作Linq的join語法 資料表Ａ 資料表B Join先來做兩個資料的Join，把資料表B去顯示對應的資料表A的WeekName，Join是算是Linq比較簡單易懂的，其條件為透過資料表A的Week與資料表B的WeekSQL這兩個欄位相等之關係之資料集 12345from ss in Config_WeekMappingsjoin aa in S_Student_Curriculumson new &#123; WeekID=ss.Week&#125; equalsnew &#123;WeekID=aa.WeekSQL&#125; select new &#123; WeekSQL=ss.Week,WeekName=ss.WeekName,week=aa.Week&#125; 跟我們熟悉的SQL語法是相同的 123SELECT [t0].[Week] AS [WeekSQL], [t0].[WeekName]FROM [Config_WeekMapping] AS [t0]INNER JOIN [S_Student_Curriculum] AS [t1] ON [t0].[Week] = [t1].[WeekSQL] 若是要這Joine過程中去過濾一些資料呢?例如我只要取資料表A中的Week等於1的資料，其語法如下: 123456from ss in Config_WeekMappingsjoin aa in S_Student_Curriculumson new &#123; WeekID=ss.Week&#125; equalsnew &#123;WeekID=aa.WeekSQL&#125; where ss.Week==1select new &#123; WeekSQL=ss.Week,WeekName=ss.WeekName&#125; 而除了一個過濾條件外，我們又想在資料表B中取出某一個學號且WeekSQL為1的資料，其語法如下: 123456from ss in Config_WeekMappingsjoin aa in S_Student_Curriculumson new &#123; WeekID=ss.Week&#125; equalsnew &#123;WeekID=aa.WeekSQL&#125; where aa.S_Num==&quot;S20142001&quot; &amp;&amp; ss.Week==1select new &#123; WeekSQL=ss.Week,WeekName=ss.WeekName&#125; 這樣就可以採用兩個條件做篩選，且可以分別篩選出不同資料表的條件。因此，即使在Linq中也可以很輕鬆的透過這樣語法做過濾條件，Linq轉成SQL語句是跟我們再用SQL指令的方式是相同的。 Right Join使用Right Join在Linq中並無真正去區分Right Join或是Left Join的關鍵字。這一點跟SQL指令不太一樣，在SQL中還可以採用Right Join &amp; Left Join去指定資料表的聯集方式。但是，在Linq這邊語法就沒有這樣直覺，Linq語法中都只有Join這指令而已，因此，先來講Right Join作法，後面再接著說Left Join，個人認為right Join比較需要換個方向思考才能與SQL相同 想要把資料表A去Right Join資料表B，其SQL語法可以這樣下: 12345678SELECT [t0].[Week] AS [WeekSQL] , [t0].[WeekName] , t1.WeekFROM [dbo].[Config_WeekMapping] [t0] RIGHT JOIN ( SELECT WeekSQL , Week FROM [dbo].[S_Student_Curriculum] ) t1 ON t0.Week = t1.WeekSQL 在Linq並無Right Join語法，因此，我做法則是把資料表兩個做對調，其意義為用資料表B去Left Join資料表A，這樣就可以達到資料表A做Right Join資料表B的功能，其與法如下: 123456from ss in S_Student_Curriculumsjoin aa in Config_WeekMappings on new &#123; WeekID=ss.WeekSQL&#125; equalsnew &#123;WeekID=aa.Week&#125; into tempfrom ds in temp.DefaultIfEmpty()select new &#123; WeekSQL=ds.Week,WeekName=ds.WeekName,week=ss.Week&#125; 而當我們在Linq語法中，無論是right join或是left Join中，要取得第一個資料表S_Student_Curriculums的欄位，直接使用上述的變數ss指向欄位即可，但是，若是要取得第二個資料表欄位Config_WeekMappings，則不是直接取用變數aa對應欄位，而是必須使用temp這個變數去對映相關欄位才可以，因此，上面語法對照的SQL語法如下: 123SELECT [t1].[Week] AS [WeekSQL], [t1].[WeekName] AS [WeekName], [t0].[Week] AS [week]FROM [S_Student_Curriculum] AS [t0]LEFT OUTER JOIN [Config_WeekMapping] AS [t1] ON [t0].[WeekSQL] = [t1].[Week] 若是這邊要做一些資料篩檢的話，就跟Join方式的是相同的概念，下面篩選案例與Join中的案例相同，其語句如下: 1234567from ss in S_Student_Curriculumsjoin aa in Config_WeekMappings on new &#123; WeekID=ss.WeekSQL&#125; equalsnew &#123;WeekID=aa.Week&#125; into tempfrom ds in temp.DefaultIfEmpty()where ss.S_Num==&quot;S20142001&quot; &amp;&amp; ds.Week==3select new &#123; WeekSQL=ds.Week,WeekName=ds.WeekName,week=ss.Week&#125; Left Join資料表A做left Join資料表B其語法如下，這部份跟right join是相同的，就把剛剛資料表B再與資料表A做對調即可 123456from ss in Config_WeekMappings join aa in S_Student_Curriculumson new &#123; WeekID=ss.Week&#125; equalsnew &#123;WeekID=aa.WeekSQL&#125; into tempfrom ds in temp.DefaultIfEmpty()select new &#123; WeekSQL=ss.Week,WeekName=ss.WeekName,week=ds.Week&#125; 當然這邊SQL語法也是跟right join是相同的，只有資料表對調而已 以上就是針對Linq做Join系列的簡單作法，不過，上述案例只有針對一個條件做Join，也就是on A.XX=B.XX，若是要針對兩個欄位進行Join呢?只要針對下圖的紅框部分，依序加入欄位就可以。 資料來源：https://dotblogs.com.tw/blog/preview/eca79cfe-642e-4d3a-a93f-e8cc2e6e6455","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://edwardkuo.github.io/tags/C/"}]},{"title":"開始進行資料庫程式的版控和佈署","slug":"SQL/2016-06-10-1","date":"2016-06-10T14:59:31.000Z","updated":"2016-06-10T15:00:52.000Z","comments":true,"path":"paper/2016/06/10/SQL/2016-06-10-1/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/SQL/2016-06-10-1/","excerpt":"","text":"在程式開發上，大家都知道要對程式碼進行版控的動作，但是，對於DB的Table Schema或是資料庫物件就不會去做版控。針對這一部份，大都採用傳統方式，用複製的動作進行版控，久而久之就會開始遺失或是缺東缺西。早期要做資料庫物件版控其實也不容易，畢竟，DB是透過Script運作。自從VisualStudio有資料庫專案後，再加上資料庫更新與建制，可以透過.dacpac封裝方式進行部署與差異化更新，因此，要把資料庫納入版控就相對簡單許多。因此，可以開始嘗試使用DB資料庫專案進行開發 首先，在Visual Studio內找到SQL Server專案範本，透過這專案範本就可以建立資料庫專案了 開啟資料庫專案後，就跟開發程式一樣簡單了，可以透過新增項目去開發資料庫的物件。若是，針對舊有的資料庫進行版控，就必須將資料庫匯入資料庫專案中，這樣後續才有辦法產生.dacpac檔案，設計完畢後，就可以透過Visual Stduio進行發行資料庫或是透過SSMS進行佈署。 個人還是喜歡透過SSMS進行操作，畢竟，實務上這一段不一定是開發人員佈署或是一般人都有權限可以直接有權限接觸DB，透過，將封裝檔案透過SSMS佈署或是更新是比較適宜的。所以，當我們設計好的資料庫專案，就可以透過編譯方式產生封裝檔案，若是中間有語法錯誤或是物件不對，就會發生編譯失敗問題。使用SSMS只要選擇佈署精靈就可以很快的佈署完畢了。先選擇要佈署的檔案，和要產生資料庫的名稱 這邊可以看到要佈署的封裝檔案的版本。 若是第一次進行封裝佈署，基本上只要不斷按下一步就可以。而若是在開發專案中有遇到資料庫更新部分，也可以透過封裝檔案進行 把某一個資料表的ID設定為識別碼並且把封裝版本號修改一下然後，透過SSMS的更新資料應用程式，進行資料庫物件的更新 當然，還是需要選擇新版本的封裝檔案 基本上若是資料庫的資料表內有資料，都會跳出警告訊息，這部分主要是告知這些異動會動到資料表，有可能會有資料表內的資料遺失風險下圖也是進行相同的提示，這邊若是不須勾選確認會資料遺失的按鈕，就無法繼續下一步了 按完之後就等他進行更新了更新完畢後，就可以看到ID已經被設定成識別碼了。 以上透過這樣方式就可以佈署資料庫，同時也可以將資料庫設計納入版控中。但是，個人覺得在第一次進行資料庫佈署時候，透過封裝檔案方式進行佈署，算是非常方便的，且相關機制都可以透過Visual Studio進行管控與紀錄。若是，當我們有針對資料庫內資料表或是相關程式更新時候，尤其是資料表部分，還是建議乖乖去資料表內透過手動或是寫好Script方式進行更新資料表以免真的有資料遺失。雖然，可以備份資料，但是，若是資料表內資料非常的多時候，有時候遺失那些資料還真的找不出來，又要做資料比對又很花時間與精神，而針對原本預存程序或是檢視表的更新，就可以透過封裝檔案進行","categories":[{"name":"資料庫程式版控","slug":"資料庫程式版控","permalink":"http://edwardkuo.github.io/categories/資料庫程式版控/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://edwardkuo.github.io/tags/T-SQL/"}]},{"title":"使用Visual Studio佈署DB，自動化填入資料","slug":"SQL/2016-06-10-2","date":"2016-06-10T14:59:31.000Z","updated":"2016-06-10T15:13:34.000Z","comments":true,"path":"paper/2016/06/10/SQL/2016-06-10-2/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/SQL/2016-06-10-2/","excerpt":"","text":"在一些實際案例上，往往佈署資料庫後，無論是要進行資料庫測試，或是要在資料表放入一些初始設定值或是初始化資料，就是先準備初始化資料的Script，等資料庫建立完畢後，再去執行這些Script放入資料，不過，若是透過透過Visual Studio資料庫專案，則可以將這部分一併做到自動化，也就是說當資料庫建立完成後，資料也一併填入資料表，這樣不僅可以在開發階段去定義要填入的資料，也可以避免資料表有異動時候，要填入資料的script沒有做變更，造成資料無法填入。 一開始做法跟開始進行資料庫程式的版控和佈署這篇教學是相同的，後面，我們只要在做放入要自動化SQL Script就可以 首先我們要加入指令碼，通常這指令碼就是SQL Script 選擇佈署後指令碼，其目的在於是當資料庫佈署完畢後才會執行，若是有些東西需要在佈署前先做，就選擇預先佈署指令碼就可以 新增完畢後的檔案內容如下，這邊只要去填入自己要塞入DB資料的Script就可以。 以上幾個簡單步驟就可以做到自動化填入資料囉。不過，運用上還需要一些小技巧，以目前手邊案例來說，因為資料有時候，有先後順序且在團隊分工上，要做到分工去完成一些填資料動作，若是都在一個檔案中去實作，要管理起來是非常麻煩的。所以，運用上我會把這檔案當作運作塞資料的主流程，然後在這檔案中用SQLCMD去執行每個要Insert Data的 Script檔案其他的.sql檔案，就可以用一般的SQL Script去產生出來然後再去定義我們要塞入資料的順序，甚至在測試時候，我們也可以放入一些測試資料的Script，等正式上線再移除這些測試的Script，這樣在管理上就方便多了完成之後，進行發布就可以了。若是你的資料有相依或是唯一性，在重複佈署時候可能會有發生資料問題，這邊只要在佈署時候選擇重新建立資料庫就可以。不過，這部分要仔細確認後再作業避免後悔","categories":[{"name":"資料庫程式版控","slug":"資料庫程式版控","permalink":"http://edwardkuo.github.io/categories/資料庫程式版控/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://edwardkuo.github.io/tags/T-SQL/"}]},{"title":"T-SQL 時間欄位的格式化(用Convert / Cast作法)","slug":"SQL/2016-06-10","date":"2016-06-10T14:59:31.000Z","updated":"2016-06-10T14:42:16.000Z","comments":true,"path":"paper/2016/06/10/SQL/2016-06-10/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/SQL/2016-06-10/","excerpt":"","text":"用T-SQL要把資料的時間輸出想要的格式是很常見的需求，例如:年月日時分秒或是年月日，在C#可以用tostring(&quot;yyyy-MM-dd&quot;)方式。在T-SQL中可以用Convert或是Cast，但是，每次用Convert時候，都還要去記住格式化的代碼有點難，這邊整理一些相關資訊，供大家參考也給自己記憶。 用Cast方式，可以轉換成下列幾種格式 分別執行結果如下: 用Convert方式，將時間欄位轉成varchar，並搭配style方式，轉換成自己要的時間格式1select convert(varchar,getdate(),填入center style) 簡碼對照表 不過，在這簡碼中，若是要轉換成年月日時分，似乎沒有這樣的格式可以用，要達到此需求，可以定義varchar長度來解決1select convert(varchar(16),getdate(),120)","categories":[],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://edwardkuo.github.io/tags/T-SQL/"}]},{"title":"ASP.NET 強制設定開啟或是關閉相容性檢視","slug":"Web/2016-06-10","date":"2016-06-09T14:59:31.000Z","updated":"2016-06-10T14:29:52.000Z","comments":true,"path":"paper/2016/06/09/Web/2016-06-10/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/09/Web/2016-06-10/","excerpt":"","text":"通常網頁在開發上，最怕就是整個版型跑掉，因為，網頁系統上的UI版型跑掉是最麻煩一件事情，但是往往因為，目前網頁開發技術並未統一，且又有可能有舊版的系統在使用。因此，IE上面會有相容性檢視的功能讓新版IE可以再使用舊版的系統(大都是IE8年代以前開發的系統)的版型不會跑掉。 在企業內部一般來說，因為很多年代久遠系統，所以，可能預設會把相容性檢視打該，但是，若是今天自己開發網站是用像是HTML5 + CSS3開發可能這樣版型在設定相容性模式下就會跑掉，但是，不太大可能讓使用者取消這設定，畢竟除新系統之外，還有成千上萬就系統還是要能執行。因此，我們可以在Web.config加入下面這一段，關閉相容性檢視這網站。或是開啟相容性檢視這網站 關閉相容性檢視 12345678&lt;system.webServer&gt; &lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;clear /&gt; &lt;add name=&quot;X-UA-Compatible&quot; value=&quot;IE=Edge&quot; /&gt; &lt;/customHeaders&gt; &lt;/httpProtocol&gt;&lt;/system.webServer&gt; 開啟相容性檢視 12345678&lt;system.webServer&gt; &lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;clear /&gt; &lt;add name=&quot;X-UA-Compatible&quot; value=&quot;IE=EmulateIE7&quot; /&gt; &lt;/customHeaders&gt; &lt;/httpProtocol&gt;&lt;/system.webServer&gt; 以上兩段就可以透過自己系統定義IE瀏覽器要不要開關相容性檢視了","categories":[],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://edwardkuo.github.io/tags/ASP-NET/"}]},{"title":"Azure Web App Inbound IP和Outbound IP的不同","slug":"Azure/2016-06-10","date":"2016-06-06T12:09:34.000Z","updated":"2016-06-10T14:32:23.000Z","comments":true,"path":"paper/2016/06/06/Azure/2016-06-10/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/06/Azure/2016-06-10/","excerpt":"","text":"Azure Web App有分為兩種類型的IP位址，一種是Inbound IP，一種是Outbound IP Inbound IP是所謂內部虛擬IP，一般你沒有綁定SSL憑證時，這個IP是與大家分享的 Outbound IP是對外的實體IP，這個IP取決於資料中心的配置，通常是四個IP輪詢 Inbound ＆ Outbound最簡單識別方式就是 A Web Site Call B Web Site 時，在B Web Site看到呼叫端的A Web Site IP就是屬於A Web Site的Outbound IP，B Web Site則是用Inbound接收A Web Site的Request 通常我們是不需要去管Web Site Outbound IP，不過，在某些情境下為了去設定防火牆，讓我們的Azure Web App能呼叫企業內部的服務或是網站，就必須去知道Web Site Outbound IP，才有辦法設定防火牆通過 outbound IP List列出所有Azure資料中心的Outbound IP，不過，為了以防萬一這些資訊有所變更不在這列表中，還可以用另一種方式去找到Outbound IP，就是到Azure Portal中的Web App內去找 先找到該Web App，然後到它的屬性內的Outbound IP 就可以查看這Web Site的Outbound IP，通常是都會配四組Outbound IP給這個Web Site 如果不想要透過這種方式去查詢Outbound IP，也可以使用Azure Resource Explorer這個工具去查詢，Azure Resource Explorer的網址https://resources.azure.com，它是一個可以發現Azure服務API的一個Web工具，雖然並非所有Azure服務都有支援，使用ARE好處如下： 取得Azure 服務的API 取得API相關資訊 可以直接使用上面API，更新你服務的設定 這個工具目前尚在Preview階段，所以，部分功能還不完整。以目前要查Outbound IP為例，只要去找到你所屬的Web Site名稱，就可以在旁邊的Json資訊中找到outboundIpAddresses Key，然後就可以發現此Web Site的Outbound IP List如果，有用中國Azure的人，目前此工具還不支援，再加上又沒有新的Portal可以支援查詢，因此，列出北京與上海資料中心的Outbound IP給有需要的人 Scale Unit Name: BJB-001 （北京資料中心） Outbound IP Addresses 42.159.4.73 42.159.4.84 42.159.4.211 42.159.4.160 Scale Unit Name: SHA-001 （上海資料中心） Outbound IP Addresses 42.159.135.109 42.159.135.174 42.159.135.208 42.159.133.172","categories":[],"tags":[{"name":"Azure","slug":"Azure","permalink":"http://edwardkuo.github.io/tags/Azure/"}]},{"title":"建立Azure上海與香港資料中心Site to Site VPN","slug":"Azure/2016-06-10-1","date":"2016-06-02T14:59:31.000Z","updated":"2016-06-10T14:33:01.000Z","comments":true,"path":"paper/2016/06/02/Azure/2016-06-10-1/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/02/Azure/2016-06-10-1/","excerpt":"","text":"如果有同時使用China Azure和Global Azure，遇到最麻煩的事情，就是怎樣把兩邊的資料做整合，一方面是兩邊的Azure功能性不一致，另一方面是因為中國長城關係，導致資料Sync不能透過一般HTTP解決，因此，為了解決這問題，只好建立一組Site to Site的VPN，解決雙方的Azure資料中心的溝通問題 先自行規劃上海資料中心和香港資料中心的網路IP分配12* 上海資料中心：10.1.0.0 /16，名稱：CN-NET* 香港資料中心：10.2.0.0 /16，名稱：HK-NET 開始設定Azure的虛擬網路吧，先設定CN-NET這部分 虛擬網路名稱取名為CN-NET 這邊選 設定網站間VPN 設定香港資料中心的虛擬網路資訊，名稱設定為HK-NET，名稱後續要跟設定香港資料中心的名稱一樣，位置空間的IP就設定IP:10.2.0.0 /16 VPN裝置的IP位址，可以先隨便設定一個，後面會改掉，但是，設定的IP不可以跟你後續香港或是上海資料中內的位址IP有重複，不然會發生錯誤 設定上海資料中心的虛擬網路的IP10.1.0.0 /16，然後再設定Subnet IP 10.1.1.0 /29，按下確定就可以 上海資料中心設定完成後，再來設定香港資料中心，幾乎步驟都相同，只有在設定的地方不一樣 這邊依舊選 設定網站間VPN 改設定上海資料中心的虛擬網路資訊，所以名稱設定為CN-NET，位址IP10.1.0.0 /16，這邊的VPN IP位址，也可以先隨便設定一個，同樣的不可以跟你後續香港或是上海資料中內的位址重複，不然會出現錯誤 設定香港資料中心的虛擬網路的IP10.2.0.0 /16，在設定Subnet IP 10.2.1.0 /29，按下確定就可以設定完成 兩邊資料中心都設定完成後，在兩邊設定畫面中，就會出現VNET組態檔，這時候我們要把這組態檔匯出來 下載出來的組態檔內容如下，我們後續會修改組態檔中的 VPNGatewayaddress 的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;NetworkConfiguration xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://schemas.microsoft.com/ServiceHosting/2011/07/NetworkConfiguration&quot;&gt; &lt;VirtualNetworkConfiguration&gt; &lt;Dns /&gt; &lt;LocalNetworkSites&gt; &lt;LocalNetworkSite name=&quot;HK-NET&quot;&gt; &lt;AddressSpace&gt; &lt;AddressPrefix&gt;10.2.0.0/16&lt;/AddressPrefix&gt; &lt;/AddressSpace&gt; &lt;VPNGatewayAddress&gt;2.2.2.2&lt;/VPNGatewayAddress&gt; &lt;/LocalNetworkSite&gt; &lt;LocalNetworkSite name=&quot;v-net-west&quot;&gt; &lt;AddressSpace&gt; &lt;AddressPrefix&gt;10.200.0.0/16&lt;/AddressPrefix&gt; &lt;/AddressSpace&gt; &lt;VPNGatewayAddress&gt;23.99.112.76&lt;/VPNGatewayAddress&gt; &lt;/LocalNetworkSite&gt; &lt;/LocalNetworkSites&gt; &lt;VirtualNetworkSites&gt; &lt;VirtualNetworkSite name=&quot;CN-NET&quot; Location=&quot;China East&quot;&gt; &lt;AddressSpace&gt; &lt;AddressPrefix&gt;10.1.0.0/16&lt;/AddressPrefix&gt; &lt;/AddressSpace&gt; &lt;Subnets&gt; &lt;Subnet name=&quot;Subnet-1&quot;&gt; &lt;AddressPrefix&gt;10.1.0.0/24&lt;/AddressPrefix&gt; &lt;/Subnet&gt; &lt;Subnet name=&quot;GatewaySubnet&quot;&gt; &lt;AddressPrefix&gt;10.1.1.0/29&lt;/AddressPrefix&gt; &lt;/Subnet&gt; &lt;/Subnets&gt; &lt;Gateway&gt; &lt;ConnectionsToLocalNetwork&gt; &lt;LocalNetworkSiteRef name=&quot;HK-NET&quot;&gt; &lt;Connection type=&quot;IPsec&quot; /&gt; &lt;/LocalNetworkSiteRef&gt; &lt;/ConnectionsToLocalNetwork&gt; &lt;/Gateway&gt; &lt;/VirtualNetworkSite&gt; &lt;VirtualNetworkSite name=&quot;v-net-china&quot; Location=&quot;China East&quot;&gt; &lt;AddressSpace&gt; &lt;AddressPrefix&gt;10.100.0.0/16&lt;/AddressPrefix&gt; &lt;/AddressSpace&gt; &lt;Subnets&gt; &lt;Subnet name=&quot;Subnet-1&quot;&gt; &lt;AddressPrefix&gt;10.100.0.0/24&lt;/AddressPrefix&gt; &lt;/Subnet&gt; &lt;Subnet name=&quot;GatewaySubnet&quot;&gt; &lt;AddressPrefix&gt;10.100.1.0/29&lt;/AddressPrefix&gt; &lt;/Subnet&gt; &lt;/Subnets&gt; &lt;Gateway&gt; &lt;ConnectionsToLocalNetwork&gt; &lt;LocalNetworkSiteRef name=&quot;v-net-west&quot;&gt; &lt;Connection type=&quot;IPsec&quot; /&gt; &lt;/LocalNetworkSiteRef&gt; &lt;/ConnectionsToLocalNetwork&gt; &lt;/Gateway&gt; &lt;/VirtualNetworkSite&gt; &lt;/VirtualNetworkSites&gt; &lt;/VirtualNetworkConfiguration&gt;&lt;/NetworkConfiguration&gt; 在兩處的Azure虛擬網路部分，建立閘道，選定 動態路由 建立閘道時間會比較長，可能要20多分鐘以上，路由建立好後，會出現下面樣子 再回到剛剛的組態檔案，從CN-NET得到的閘道IP，修改從HK-NET下載的組態檔中的VPNgetwayaddress的值，然後再到香港資料中心取得其閘道IP，再將這閘道IP，取代從CN-NET下載的組態檔案中的VPNgetwayaddress的值 都設定好之後，分別上傳組態檔案，上海組態檔上傳到上海資料中心，香港組態檔上傳到香港資料中心 上面會顯示有被更新的資訊，直接確認就可以 到了這一步，基本上在介面上的設定都完畢，剩下就必須透過Powershell去把這兩邊的資料中心連線串接起來 首先先設定上海資料中心部分，使用Powershell去取得中國的Azure帳號，其指令是 1Add-AzureAccount -Environment AzureChinaCloud 登入後，使用 1Select-AzureSubscription -SubscriptionId &quot;訂閱號碼“ 選定我們的訂閱戶，開始配置兩邊的共享金鑰，金鑰名稱可以自行輸入，但是，兩邊資料中心的金鑰要使用一樣，如果在上海資料中心，設定的VNetName就是CN-Net，LocalNetworkSiteName就是hk-Net 1Set-AzureVNetGatewaykey -VNetName CN-NET -LocalNetworkSiteName HK-NET –SharedKey 金鑰 設定香港的資料中心 1Set-AzureVNetGatewaykey -VNetName HK-NET -LocalNetworkSiteName CN-NET –SharedKey 金鑰 兩邊都設定成功後，請再等待幾分鐘，就可以看到這兩邊的VNET串接起來了 如果不確定，也可以透過Powershell指令去查看1Get-AzureVnetConnection –VnetName HK-NET 這樣中國與Global兩邊資料中心的虛擬網路就串起來了，最後提醒一下，是設定Site to Site，而不是Point to Site VPN唷","categories":[],"tags":[{"name":"Azure","slug":"Azure","permalink":"http://edwardkuo.github.io/tags/Azure/"}]}]}