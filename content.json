{"meta":{"title":"E.K 2.0","subtitle":"Product Owner & Coach & Developer 混合體","description":"科技 & 人文 & 啟發","author":"Edward kuo","url":"http://edwardkuo.github.io"},"pages":[{"title":"Edward Kuo","date":"2016-06-10T16:15:04.000Z","updated":"2016-06-10T16:15:04.000Z","comments":true,"path":"about/about.html","permalink":"http://edwardkuo.github.io/about/about.html","excerpt":"","text":"架構不是設計出來，是迭代出來的 喜愛跨界研究各種技術，探討如何從需求面進行全面性的架構設計，小有研究製造業的供應鏈管理與流程改善。目前，偏向研究產品在互聯網的創新，社群媒體的運營以及服務設計，歡迎大家一起來交流，另一個Blog 現職 某全球知名品牌公司 資訊主管 好朋友工坊 資訊顧問 財團法人福榮融合教育推廣基金會 資訊義工 雲林科技大學工業工程與管理系課程 委員 Study4.TW 講師 獎項 Microsoft® MVP MVP 社群活動突出貢獻獎 Certified Scrum Developer Certified Scrum Master Certified Product Owner 擔任講者 Global Windows Azure Bootcamp Microsoft Community Rising Star appraise 中國第十屆五金工業設計大賽 評委 國立東華大學 全球供應鏈管理講師 漢翔航空工業 全球生產排程規劃講師 雲林科技大學 全球供應鏈管理暨生產排程規劃講師…"},{"title":"整理個人愛用的Sublime外掛套件","date":"2016-01-20T20:48:33.000Z","updated":"2016-06-10T12:25:34.000Z","comments":true,"path":"sublime/Sublime.html","permalink":"http://edwardkuo.github.io/sublime/Sublime.html","excerpt":"","text":"因為工作需要，開始做一些Font-End的工作，雖然，Visuao Stduio已經非常好用，但是，就前端工程師來說用的比較多還是Sublime，Sublime好用這裡就不做介紹，我們知道它是一個輕量化的編輯軟體，很多功能都是你需要時候才透過Plugin方式來安裝，若是，你安裝Plug-in套件，這東西就跟筆記本沒啥兩樣，所以，外掛選用就變成是一件重要的東西。諷刺的是，若是外掛裝多，這東西也就龐大，當然效能也就變慢了，一個好的方式就是下載免安裝版本的sublime，依照在不同工作需求去產生不同的sublime執行資料夾，避免同一個sublime裝太多套件變慢了 紅框為可攜帶版本，也就是說套件裝好後，可以任意攜帶到其他電腦繼續使用，不需要重裝套件 要安裝套件時候，記得必須先安裝Package install panel套件，安裝方法可以參考 http://packagecontrol.io/installation 陸陸續續整理一些不錯的套件給大家使用，若是有好的套件也歡迎推薦給我 ChinesOpenConvert 主要是做繁體與簡體轉換，除了文字轉換，還會針對慣用語的轉換，慣用語轉換的準確度還算可以 SASS &amp; SCSS 要用SASS寫CSS的話，兩個語法在原本sublime是沒有支援，必須額外安裝。不過，可以依照自己愛用哪一種語法去開發，安裝其中一個就可以 Html-CSS-JS Prettify 支援HTML &amp; CSS &amp; JS排版的套件，透過它可以美化程式版型，在使用之前，電腦必須安裝Node.JS，它是基於Node.jS下的運作的套件未安裝前的格式美化後的樣式 sidebarenhancements 讓Sublime的側邊功能加強原本有的功能只有下面這樣，功能看起來少少的安裝完畢後，可以發現側邊欄位的功能變成很多了 ConvertToUTF8 預設sublime並不支援utf8，避免後續出現亂碼，這套件幾乎是必須安裝的 Emmet 讓我們可以快速產生Html Tag的套件，透過這套件可以簡化很多打字的力氣例如:你只要在空白頁面打入 ! + Tab，就會出現下面圖樣，Tag都幫你做好了又或是你要打槽狀的Html Tag，可以這樣打div&gt;p&gt;span + Tab，這語法其實不需死記，因為這語法其實就是跟撰寫CSS是相同的，只要會撰寫CSS就可以快速建立這樣結構 更多語法可以參考http://docs.emmet.io AutoFileName 當我們在使用一些Tag需要用到資料夾內的各個檔案路徑時候，會自動幫我們顯示出來這樣好處在於，可以快速找到我們要的檔案，也可以省掉打一些路徑的時間"}],"posts":[{"title":"管理Azure Resources內的Resources Group","slug":"Azure/2016-06-11","date":"2016-06-11T14:59:31.000Z","updated":"2016-06-11T12:24:57.000Z","comments":true,"path":"paper/2016/06/11/Azure/2016-06-11/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/11/Azure/2016-06-11/","excerpt":"","text":"之前在Azure開一些服務時候，它會自動配置一個Resources Group給你，又或是一開始在規劃架構時候，我們都會自行會設定一些Resources Group，但是久了之後，可能因為業務需求變動下，導致在Azure的服務被分得很零散，要管理起來就不是很方便或是很直覺。 在Azure的Resources Group設計中，是讓我們很容易去管理Azure服務。因此，對於初期架構設計的一些『錯誤』或是業務的變更，後面還是必須想辦法去彌補或是去更新，才不會等到最後架構變大，服務變多了，要管理起來也就更不方便 例如：業務A的Web App和SQL Database分散在不同Resources Group，我們定義一個名叫A Resources Group，把分散在各地屬於A服務的資源放在一起，要怎樣做呢？ Move SQL Database 首先，把SQL Database搬到新的Resources Group，這部分可以在新的Azure Portal 去做搬遷，記住搬遷SQL Database，一定要連同SQL Database Server一起搬遷，不能只有把Database進行轉移，所以，在SQL Server選擇『Move』就可以開始進行轉移 選擇要遷入的Resource Group名稱，按下確定之後，就可以進行搬遷囉，在搬遷時候，服務會停止一下，不過，時間不確定要多長，以目前這個SQL Database Size比較小，在30秒內就可以完成搬遷 Storage Move 搬遷Storage，搬遷Storage步驟就多一點點，選擇storage的屬性 往下滑動，就可以找到Resource Group，在這邊就可以變換Resource Group 選擇要搬遷的Storage，就可以開始進行搬遷了 Web App Move移動App Servie方式也跟移動Storage一樣，到屬性的地方去修改要移動到的Resource Group，就可以把資源給轉移了，不過，這邊有一個陷阱，就是你在轉移Web App，記得所屬的App Service Plan也要一併轉移，不然到時候會無法把原本的Web App去轉移到其他的App Service Plan。這樣會出現Service Plan橫跨不同Resource Group的錯誤。 此外，在Web App轉移上，目前有一個限制，就是如果在一個Resource Group裡面有多個App Service Plan，就無法做移轉的動作，換句話說想要做移轉，必須確保Resource Group內只有一個App Service Plan才行，如下圖，這樣是無法進行移轉的 如果還是強行移轉，在Portal是看不到錯誤資訊，只是不會有動作，如果用PowerShell去跑，就會出現下面錯誤，這一點要注意的 如果不想透過Portal去做轉移，也可以使用PowerShell去控制123$webapp = Get-AzureRmResource -ResourceGroupName OldResourceGroupName -ResourceName ResourceName$plan = Get-AzureRmResource -ResourceGroupName OldResourceGroupName -ResourceName ResourceNameMove-AzureRmResource -DestinationResourceGroupName NewResourceGroupName -ResourceId $webapp.ResourceId, $plan.ResourceId","categories":[],"tags":[{"name":"Azure","slug":"Azure","permalink":"http://edwardkuo.github.io/tags/Azure/"}]},{"title":"用C#做查詢,建立及刪除檔案目錄功能","slug":"Net/2016-06-11-1","date":"2016-06-11T14:59:31.000Z","updated":"2016-06-11T15:02:44.000Z","comments":true,"path":"paper/2016/06/11/Net/2016-06-11-1/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/11/Net/2016-06-11-1/","excerpt":"","text":"常常會用到對作業系統進行建立資料夾或是刪除資料動作，所謂，程式寫完超過三個月就會忘記，真的是一點都沒錯。為了避免每次自己都還要去查一下MSDN來做回憶。這邊把一些相關基礎做法做一個筆記，日後也可以比較容易查閱 首先需要加入這個using System.IONamespace 判斷目錄是否存在可以使用DirectoryInfo這個Class進行處理。這案例是我們判斷在C槽下是否有存在Temp目錄，用exists屬性來判斷，路徑的表示法C#與VB有所不同，請自行查閱。 DirectoryInfo : 公開建立、移動和全面列舉目錄和子目錄的執行個體 (Instance) 方法 12345678910string strFolderPath = @&quot;C:\\temp\\&quot;;DirectoryInfo DIFO = new DirectoryInfo(strFolderPath);if (DIFO.Exists)&#123; Console.WriteLine(&quot;Exist&quot;);&#125;else&#123; Console.WriteLine(&quot;No Exist&quot;);&#125; 在C槽已經存在Temp目錄所以或出現Exist，其中路徑無論是寫 @”C:\\temp\\” 或是 @”C:\\temp” 其結果都是相同的 建立目錄使用Create的方法來建立，若是該目錄已經存在則不會有所動作123string strFolderPath = @&quot;C:\\temp\\test1&quot;;DirectoryInfo DIFO = new DirectoryInfo(strFolderPath);DIFO.Create(); 若是我們要在該目錄下，不斷建立該目錄的子目錄，不需要重複寫上面那一段Code然後把路徑置換，只需要使用CreateSubdirectory方法就可以1234string strFolderPath = @&quot;C:\\temp\\test1\\&quot;;DirectoryInfo DIFO = new DirectoryInfo(strFolderPath);DirectoryInfo ss = DIFO.CreateSubdirectory(&quot;GG&quot;);DirectoryInfo sq = ss.CreateSubdirectory(&quot;FF&quot;); 這樣就可以在test1目錄下面建立GG目錄，在GG目錄下建立FF目錄了 刪除目錄使用Delete的方法來刪除123string strFolderPath = @&quot;C:\\temp\\test1\\&quot;;DirectoryInfo DIFO = new DirectoryInfo(strFolderPath);DIFO.Delete(); 不過，這邊有一個重點，若是該目錄不是空的，執行這樣語法會出現錯誤，早期的作法可能需要將資料目錄先清空再去刪除，不過，現在已經不需要這樣麻煩，只需要在Delete中傳入，是否要一併刪除該資料內所有檔案或是目錄就可以，True是表示要刪除該資料夾下所有資料，False則反之。123string strFolderPath = @&quot;C:\\temp\\test1\\&quot;;DirectoryInfo DIFO = new DirectoryInfo(strFolderPath);DIFO.Delete(true); 補充一下，取得該資料夾所有檔案的方式，藉由FileInfo取檔案名稱1234foreach (FileInfo di in DIFO.GetFiles())&#123; Console.WriteLine(di.FullName);&#125; 若是找到目錄就移除該目錄，並重新建立目錄方式12345678910string strFolderPath = @&quot;C:\\temp\\&quot;;DirectoryInfo DIFO = new DirectoryInfo(strFolderPath); if (DIFO.Exists)&#123; DIFO.Delete(true);&#125;else&#123; DIFO.Create(); &#125;","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://edwardkuo.github.io/tags/C/"}]},{"title":"透過HttpWebRequest取得網頁內容","slug":"Net/2016-06-11","date":"2016-06-11T14:59:31.000Z","updated":"2016-06-11T12:42:38.000Z","comments":true,"path":"paper/2016/06/11/Net/2016-06-11/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/11/Net/2016-06-11/","excerpt":"","text":"資料來源的取得，除了讀取DB內的資訊外，有時候也需要爬網頁的資訊取得，畢竟，有些資料不屬於自己控管，就必須透過這樣方式取得資料。 因此，在C#中可以透過HttpWebRequest方式去獲取網頁資料，再將資訊分析出來，取得屬於自己所要的資訊。大多數的網頁，都可以透過HTTP獲取，所以，透過HttpWebRequest提供WebRequest類別的HTTP 特定實作方式 使用HttpWebRequest，我們需要先初始化一個WebRequest類別，MSDN說明如下: WebRequest 是從網際網路存取資料的 .NET Framework 要求/回應模型的 abstract 基底類別。 使用要求/回應模型的應用程式可以用不驗證通訊協定 (Protocol) 的方式，從網際網路要求資料，其中應用程式和 WebRequest 類別的執行個體 (Instance) 一起作用，而特定通訊協定的子代 (Descendant) 類別會完成要求的細節。 創建一個WebRequest物件 1WebRequest myWebRequest = WebRequest.Create(&quot;Http://google.com&quot;); 設定呼叫時候的Timeout時間，這邊時間點是以毫秒為單位 1myWebRequest.Timeout=10000; 是在公司或是需要認證的才有辦法獲取的網頁地方，需要增加認證的帳號密碼與Domain Name 1myWebRequest.Credentials = new NetworkCredential(&quot;Name&quot;, &quot;PWD&quot;, &quot;Domain Name&quot;); 若是需要透過proxy，也須設定proxy。在proxy設定中，我們可以設定proxy跟不需要透過proxy的IP List或是host name，或是在local端判定是否需要通過Proxy 1myWebRequest.Proxy = new WebProxy(new Uri(&quot;http://proxy.hinet.net:8080&quot;), true, strByPassIP); strByPassIP是屬於陣列型態。其設定如下，主要針對192.168.XX.XX及172.17.XX.XX網段不需要走Proxy 1string[] strByPass = new string[] &#123; @&quot;192.\\.168\\..*&quot;, @&quot;172\\.17\\..*&quot; &#125;; 若是指定IP則方式如下: 1string[] strByPass = new string[] &#123; &quot;192.1.1.1&quot;, &quot;192.2.2.2&quot; &#125;; 基於安全性考量，有些Proxy也會需要指定帳號密碼與Domain Name(公司內部)，此時也需要設定通過Proxy之帳號密碼 1myWebRequest.Proxy.Credentials = new NetworkCredential(&quot;Name&quot;, &quot;PWD&quot;, &quot;Domain Name&quot;); 以上簡單幾個步驟就可以設定好WebRequest物件相關屬性，完整的Code如下:123456789internal static WebRequest CreateWebRequest()&#123; WebRequest myWebRequest = WebRequest.Create(&quot;Http://google.com&quot;); myWebRequest.Timeout=10000; myWebRequest.Credentials = new NetworkCredential(&quot;Name&quot;, &quot;PWD&quot;, &quot;Domain Name&quot;); myWebRequest.Proxy = new WebProxy(new Uri(&quot;http://proxy.hinet.net:8080&quot;), true, strByPassIP); myWebRequest.Proxy.Credentials = new NetworkCredential(&quot;Name&quot;, &quot;PWD&quot;, &quot;Domain Name&quot;); return myWebRequest &#125; 再來就是定義HttpWebRequest取得網頁字串相關方式1HttpWebRequest myHttpWebRequest = (HttpWebRequest)(CreateWebRequest(&quot;Http://google.com&quot;)); 設定HttpWebRequest相關屬性 設定Timeout時間，這邊時間點是以毫秒為單位 1myHttpWebRequest.Timeout =10000 設定取得網頁方式 1myHttpWebRequest.Method=&quot;GET&quot; 設定用戶端瀏覽器的原始使用者代理字串 1myHttpWebRequest.UserAgent=&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; Windows NT 5.2; Windows NT 6.0; Windows NT 6.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727; MS-RTC LM 8; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET CLR 4.0C; .NET CLR 4.0E)&quot; 以上屬性設定好之後，透過WebResponse物件，取得回傳的response資訊1WebResponse myWebResponse = myHttpWebRequest.GetResponse() 雖然，網頁都是文字型態，抓取網頁時還是必須要用資料流方式取的相關資訊。因此，我們需要透過GetResponseStream接收傳回來的網際網路資源的資料流，若是只單純當作字串接收，將會出現錯誤。1234567using (Stream myStream = myWebResponse.GetResponseStream())&#123; using (StreamReader myStreamReader = new StreamReader(myStream) &#123; string strHtml = myStreamReader.ReadToEnd(); &#125; &#125; 以上方式將可以取得網頁內容回傳的資訊。完整的Code如下： 123456789101112131415string strHtml = string.Empty;HttpWebRequest myHttpWebRequest = (HttpWebRequest)(CreateWebRequest(_strUrl));myHttpWebRequest.Timeout =10000;myHttpWebRequest.Method=&quot;GET&quot;;myHttpWebRequest.UserAgent=&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; Windows NT 5.2; Windows NT 6.0; Windows NT 6.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727; MS-RTC LM 8; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET CLR 4.0C; .NET CLR 4.0E)&quot;;using (WebResponse myWebResponse = myHttpWebRequest.GetResponse())&#123; using (Stream myStream = myWebResponse.GetResponseStream()) &#123; using (StreamReader myStreamReader = new StreamReader(myStream) &#123; strHtml = myStreamReader.ReadToEnd(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://edwardkuo.github.io/tags/C/"}]},{"title":"在MAC中的Visual Studio Code編譯ionic的Cordova專案","slug":"App/2016-06-10","date":"2016-06-10T15:59:31.000Z","updated":"2016-06-10T15:31:43.000Z","comments":true,"path":"paper/2016/06/10/App/2016-06-10/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/App/2016-06-10/","excerpt":"","text":"在MAC 中用Visual Studio Code開發已經越來越稀鬆平常，實際上有些時候還是會有一些雷和步驟需要克服，畢竟，用Visual Studio Code在開發Cordova還是沒有比Visual Studio來的簡單，但是，其中最大好處就是可以快速使用iOS模擬器，不需要再去設定Remote MAC的一些設定 要在MAC啟動Visual Studio Code去編譯 Codova大概需要一些基礎設定才可以讓你的Cordova專案在MAC的Visual Studio啟動。 記得要安裝好npm和Nod.js套件，前者基本上因該都有內建在OSX裡面 在Visual Studio Code中安裝Cordova 編譯器 Mac中安裝Cordova套件 1sudo npm install -g cordova MAC安裝ionic 套件 1sudo npm install -g ionic 有時候套件版本會影響使用ionic開發上的一些問題，所以我們可以透過指令看目前安裝的版本是多少，以及自己現在的Cordova版本也可以知道 1ionic info 這時候看似美好，因該可以編譯Cordova和啟動模擬器，若是你的模擬器是採用Serve to the browser這時候會出現下面錯錯誤訊 [cordova-debug-adapter] Error: Serving to the browser is currently only supported ionic 1 project 要解決這問題，就必須升級你在MAC中的ionic套件，通常這會發生你在Visual Studio開發Cordova專案後，把這專案又拿到MAC的Visual Studio Code內使用造成，升級ionic套件必須先到此Cordova專案中的www目錄下，使用ionic update的指令:1ionic lib update 就可以解決這問題 在原本Cordova專案的www目錄下又會多出一個lib的目錄，以上都安裝好之後，預設會有ios模擬器，如果需要android device，請務必另外在安裝android device模擬器，才有辦法啟動了","categories":[],"tags":[{"name":"Cordova","slug":"Cordova","permalink":"http://edwardkuo.github.io/tags/Cordova/"}]},{"title":"C# 使用For和Foreach讀取Datatable每筆資料對照寫法","slug":"Net/2016-06-10-1","date":"2016-06-10T14:59:31.000Z","updated":"2016-06-10T14:30:37.000Z","comments":true,"path":"paper/2016/06/10/Net/2016-06-10-1/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/Net/2016-06-10-1/","excerpt":"","text":"早期各種程式語法針對迴圈寫法，總是用for來實作，這東西真是好用且還歷久不衰，不過，到了開始有Foreach之後，很多迴圈寫法都會改用Foreach實作，畢竟，Foreach算是好物之一。但是，因為長時間習慣用for語法，要一時改變還真不簡單，所以，趁現在趕快紀錄一下避免忘記 採用For迴圈方式讀Datatable，其中邏輯是要判斷不是第一筆要處理的相關邏輯程式12345678910111213141516171819202122232425for (int i = 0; i &lt; _dt.Rows.Count; i++)&#123; if (strReportID != _dt.Rows[i][&quot;s&quot;].ToString()) &#123; if (i != 0) &#123; dr[&quot;R&quot;] = sb.ToString(); dt.Rows.Add(dr); sb = new StringBuilder(); dr = dt.NewRow(); &#125; strReportID = _dt.Rows[i][&quot;s&quot;].ToString(); dr[&quot;ss&quot;] = _dt.Rows[i][&quot;ss&quot;].ToString(); sb.Append(_dt.Rows[i][&quot;Name&quot;] + &quot;&lt;br /&gt;&quot;); &#125; else &#123; sb.Append(_dt.Rows[i][&quot;Name&quot;] + &quot;&lt;br /&gt;&quot;); &#125;&#125;dr[&quot;R&quot;] = sb.ToString();dt.Rows.Add(dr); 2.用Foreach寫法後，原本判斷是否為第一筆的邏輯，就要改用boolen方式去判斷。且原本是 _dt.Rows[i]的方式就可以省略，改用Datarow物件代替12345678910111213141516171819202122232425bool bFirst = false;foreach (DataRow od in _dt.Rows)&#123; if (strReportID != od[&quot;s&quot;].ToString()) &#123; if(!bFirst) &#123; dr[&quot;R&quot;] = sb.ToString(); dt.Rows.Add(dr); sb = new StringBuilder(); dr = dt.NewRow(); bFirst = true; &#125; strReportID = od[&quot;s&quot;].ToString(); dr[&quot;ss&quot;] = od[&quot;ss&quot;].ToString(); sb.Append(od[&quot;Name&quot;] + &quot;&lt;br /&gt;&quot;); &#125; else &#123; sb.Append(od[&quot;Name&quot;] + &quot;&lt;br /&gt;&quot;); &#125; &#125;dr[&quot;R&quot;] = sb.ToString();dt.Rows.Add(dr);","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://edwardkuo.github.io/tags/C/"}]},{"title":"C# 無條件進位,無條件捨去及四捨五入寫法","slug":"Net/2016-06-10-2","date":"2016-06-10T14:59:31.000Z","updated":"2016-06-10T14:31:30.000Z","comments":true,"path":"paper/2016/06/10/Net/2016-06-10-2/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/Net/2016-06-10-2/","excerpt":"","text":"雖然程式很簡單，但是，一時要用還真的不知道要怎樣寫，畢竟現在一個程式開發者要記憶的東西太多，所以，不時時刻刻記憶一些東西還真的不行呢 無條件進位 123double s = 100;int result = 0;result = Convert.ToInt16(Math.Ceiling(s / 3)); 無條件捨去 123double s = 100;int result = 0;result =Convert.ToInt16( Math.Floor(s / 3)); 四捨五入使用Math.Round， Math.Round(計算值,小數點第幾位) 123double s = 110;double result = 0;result = Math.Round((s / 3), 2); 若是要呈現一般認知的四捨五入需加入第三個參數，MidpointRounding.AwayFromZer 1System.Math.Round(1.235 , 2, MidpointRounding.AwayFromZero) 參考來源：http://msdn.microsoft.com/zh-tw/library/ef48waz8(v=VS.100).aspx","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://edwardkuo.github.io/tags/C/"}]},{"title":"使用Visual Studio佈署DB，自動化填入資料","slug":"SQL/2016-06-10-2","date":"2016-06-10T14:59:31.000Z","updated":"2016-06-10T15:17:26.000Z","comments":true,"path":"paper/2016/06/10/SQL/2016-06-10-2/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/SQL/2016-06-10-2/","excerpt":"","text":"在一些實際案例上，往往佈署資料庫後，無論是要進行資料庫測試，或是要在資料表放入一些初始設定值或是初始化資料，就是先準備初始化資料的Script，等資料庫建立完畢後，再去執行這些Script放入資料，不過，若是透過透過Visual Studio資料庫專案，則可以將這部分一併做到自動化，也就是說當資料庫建立完成後，資料也一併填入資料表，這樣不僅可以在開發階段去定義要填入的資料，也可以避免資料表有異動時候，要填入資料的script沒有做變更，造成資料無法填入。 一開始做法跟開始進行資料庫程式的版控和佈署這篇教學是相同的，後面，我們只要在做放入要自動化SQL Script就可以 首先我們要加入指令碼，通常這指令碼就是SQL Script 選擇佈署後指令碼，其目的在於是當資料庫佈署完畢後才會執行，若是有些東西需要在佈署前先做，就選擇預先佈署指令碼就可以 新增完畢後的檔案內容如下，這邊只要去填入自己要塞入DB資料的Script就可以。 以上幾個簡單步驟就可以做到自動化填入資料囉。不過，運用上還需要一些小技巧，以目前手邊案例來說，因為資料有時候，有先後順序且在團隊分工上，要做到分工去完成一些填資料動作，若是都在一個檔案中去實作，要管理起來是非常麻煩的。所以，運用上我會把這檔案當作運作塞資料的主流程，然後在這檔案中用SQLCMD去執行每個要Insert Data的 Script檔案其他的.sql檔案，就可以用一般的SQL Script去產生出來然後再去定義我們要塞入資料的順序，甚至在測試時候，我們也可以放入一些測試資料的Script，等正式上線再移除這些測試的Script，這樣在管理上就方便多了完成之後，進行發布就可以了。若是你的資料有相依或是唯一性，在重複佈署時候可能會有發生資料問題，這邊只要在佈署時候選擇重新建立資料庫就可以。不過，這部分要仔細確認後再作業避免後悔","categories":[{"name":"資料庫程式版控","slug":"資料庫程式版控","permalink":"http://edwardkuo.github.io/categories/資料庫程式版控/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://edwardkuo.github.io/tags/T-SQL/"}]},{"title":"T-SQL 時間欄位的格式化(用Convert / Cast作法)","slug":"SQL/2016-06-10","date":"2016-06-10T14:59:31.000Z","updated":"2016-06-10T14:42:16.000Z","comments":true,"path":"paper/2016/06/10/SQL/2016-06-10/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/SQL/2016-06-10/","excerpt":"","text":"用T-SQL要把資料的時間輸出想要的格式是很常見的需求，例如:年月日時分秒或是年月日，在C#可以用tostring(&quot;yyyy-MM-dd&quot;)方式。在T-SQL中可以用Convert或是Cast，但是，每次用Convert時候，都還要去記住格式化的代碼有點難，這邊整理一些相關資訊，供大家參考也給自己記憶。 用Cast方式，可以轉換成下列幾種格式 分別執行結果如下: 用Convert方式，將時間欄位轉成varchar，並搭配style方式，轉換成自己要的時間格式1select convert(varchar,getdate(),填入center style) 簡碼對照表 不過，在這簡碼中，若是要轉換成年月日時分，似乎沒有這樣的格式可以用，要達到此需求，可以定義varchar長度來解決1select convert(varchar(16),getdate(),120)","categories":[],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://edwardkuo.github.io/tags/T-SQL/"}]},{"title":"使用Linq的Join / right Join / Left Join","slug":"Net/2016-06-10","date":"2016-06-10T14:59:31.000Z","updated":"2016-06-10T14:28:30.000Z","comments":true,"path":"paper/2016/06/10/Net/2016-06-10/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/Net/2016-06-10/","excerpt":"","text":"用Join來做資料聯集，在T-SQL指令是常會用到的一種語法，不過，對於常寫SQL語法的人要轉換到Linq語法時，往往對於Join這語句的操作就常會感到比較陌生也不習慣要怎樣使用。因此，這邊簡單說明一下，要如何操作Linq的join語法 資料表Ａ 資料表B Join先來做兩個資料的Join，把資料表B去顯示對應的資料表A的WeekName，Join是算是Linq比較簡單易懂的，其條件為透過資料表A的Week與資料表B的WeekSQL這兩個欄位相等之關係之資料集 12345from ss in Config_WeekMappingsjoin aa in S_Student_Curriculumson new &#123; WeekID=ss.Week&#125; equalsnew &#123;WeekID=aa.WeekSQL&#125; select new &#123; WeekSQL=ss.Week,WeekName=ss.WeekName,week=aa.Week&#125; 跟我們熟悉的SQL語法是相同的 123SELECT [t0].[Week] AS [WeekSQL], [t0].[WeekName]FROM [Config_WeekMapping] AS [t0]INNER JOIN [S_Student_Curriculum] AS [t1] ON [t0].[Week] = [t1].[WeekSQL] 若是要這Joine過程中去過濾一些資料呢?例如我只要取資料表A中的Week等於1的資料，其語法如下: 123456from ss in Config_WeekMappingsjoin aa in S_Student_Curriculumson new &#123; WeekID=ss.Week&#125; equalsnew &#123;WeekID=aa.WeekSQL&#125; where ss.Week==1select new &#123; WeekSQL=ss.Week,WeekName=ss.WeekName&#125; 而除了一個過濾條件外，我們又想在資料表B中取出某一個學號且WeekSQL為1的資料，其語法如下: 123456from ss in Config_WeekMappingsjoin aa in S_Student_Curriculumson new &#123; WeekID=ss.Week&#125; equalsnew &#123;WeekID=aa.WeekSQL&#125; where aa.S_Num==&quot;S20142001&quot; &amp;&amp; ss.Week==1select new &#123; WeekSQL=ss.Week,WeekName=ss.WeekName&#125; 這樣就可以採用兩個條件做篩選，且可以分別篩選出不同資料表的條件。因此，即使在Linq中也可以很輕鬆的透過這樣語法做過濾條件，Linq轉成SQL語句是跟我們再用SQL指令的方式是相同的。 Right Join使用Right Join在Linq中並無真正去區分Right Join或是Left Join的關鍵字。這一點跟SQL指令不太一樣，在SQL中還可以採用Right Join &amp; Left Join去指定資料表的聯集方式。但是，在Linq這邊語法就沒有這樣直覺，Linq語法中都只有Join這指令而已，因此，先來講Right Join作法，後面再接著說Left Join，個人認為right Join比較需要換個方向思考才能與SQL相同 想要把資料表A去Right Join資料表B，其SQL語法可以這樣下: 12345678SELECT [t0].[Week] AS [WeekSQL] , [t0].[WeekName] , t1.WeekFROM [dbo].[Config_WeekMapping] [t0] RIGHT JOIN ( SELECT WeekSQL , Week FROM [dbo].[S_Student_Curriculum] ) t1 ON t0.Week = t1.WeekSQL 在Linq並無Right Join語法，因此，我做法則是把資料表兩個做對調，其意義為用資料表B去Left Join資料表A，這樣就可以達到資料表A做Right Join資料表B的功能，其與法如下: 123456from ss in S_Student_Curriculumsjoin aa in Config_WeekMappings on new &#123; WeekID=ss.WeekSQL&#125; equalsnew &#123;WeekID=aa.Week&#125; into tempfrom ds in temp.DefaultIfEmpty()select new &#123; WeekSQL=ds.Week,WeekName=ds.WeekName,week=ss.Week&#125; 而當我們在Linq語法中，無論是right join或是left Join中，要取得第一個資料表S_Student_Curriculums的欄位，直接使用上述的變數ss指向欄位即可，但是，若是要取得第二個資料表欄位Config_WeekMappings，則不是直接取用變數aa對應欄位，而是必須使用temp這個變數去對映相關欄位才可以，因此，上面語法對照的SQL語法如下: 123SELECT [t1].[Week] AS [WeekSQL], [t1].[WeekName] AS [WeekName], [t0].[Week] AS [week]FROM [S_Student_Curriculum] AS [t0]LEFT OUTER JOIN [Config_WeekMapping] AS [t1] ON [t0].[WeekSQL] = [t1].[Week] 若是這邊要做一些資料篩檢的話，就跟Join方式的是相同的概念，下面篩選案例與Join中的案例相同，其語句如下: 1234567from ss in S_Student_Curriculumsjoin aa in Config_WeekMappings on new &#123; WeekID=ss.WeekSQL&#125; equalsnew &#123;WeekID=aa.Week&#125; into tempfrom ds in temp.DefaultIfEmpty()where ss.S_Num==&quot;S20142001&quot; &amp;&amp; ds.Week==3select new &#123; WeekSQL=ds.Week,WeekName=ds.WeekName,week=ss.Week&#125; Left Join資料表A做left Join資料表B其語法如下，這部份跟right join是相同的，就把剛剛資料表B再與資料表A做對調即可 123456from ss in Config_WeekMappings join aa in S_Student_Curriculumson new &#123; WeekID=ss.Week&#125; equalsnew &#123;WeekID=aa.WeekSQL&#125; into tempfrom ds in temp.DefaultIfEmpty()select new &#123; WeekSQL=ss.Week,WeekName=ss.WeekName,week=ds.Week&#125; 當然這邊SQL語法也是跟right join是相同的，只有資料表對調而已 以上就是針對Linq做Join系列的簡單作法，不過，上述案例只有針對一個條件做Join，也就是on A.XX=B.XX，若是要針對兩個欄位進行Join呢?只要針對下圖的紅框部分，依序加入欄位就可以。 資料來源：https://dotblogs.com.tw/blog/preview/eca79cfe-642e-4d3a-a93f-e8cc2e6e6455","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://edwardkuo.github.io/tags/C/"}]},{"title":"開始進行資料庫程式的版控和佈署","slug":"SQL/2016-06-10-1","date":"2016-06-10T14:59:31.000Z","updated":"2016-06-10T15:00:52.000Z","comments":true,"path":"paper/2016/06/10/SQL/2016-06-10-1/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/10/SQL/2016-06-10-1/","excerpt":"","text":"在程式開發上，大家都知道要對程式碼進行版控的動作，但是，對於DB的Table Schema或是資料庫物件就不會去做版控。針對這一部份，大都採用傳統方式，用複製的動作進行版控，久而久之就會開始遺失或是缺東缺西。早期要做資料庫物件版控其實也不容易，畢竟，DB是透過Script運作。自從VisualStudio有資料庫專案後，再加上資料庫更新與建制，可以透過.dacpac封裝方式進行部署與差異化更新，因此，要把資料庫納入版控就相對簡單許多。因此，可以開始嘗試使用DB資料庫專案進行開發 首先，在Visual Studio內找到SQL Server專案範本，透過這專案範本就可以建立資料庫專案了 開啟資料庫專案後，就跟開發程式一樣簡單了，可以透過新增項目去開發資料庫的物件。若是，針對舊有的資料庫進行版控，就必須將資料庫匯入資料庫專案中，這樣後續才有辦法產生.dacpac檔案，設計完畢後，就可以透過Visual Stduio進行發行資料庫或是透過SSMS進行佈署。 個人還是喜歡透過SSMS進行操作，畢竟，實務上這一段不一定是開發人員佈署或是一般人都有權限可以直接有權限接觸DB，透過，將封裝檔案透過SSMS佈署或是更新是比較適宜的。所以，當我們設計好的資料庫專案，就可以透過編譯方式產生封裝檔案，若是中間有語法錯誤或是物件不對，就會發生編譯失敗問題。使用SSMS只要選擇佈署精靈就可以很快的佈署完畢了。先選擇要佈署的檔案，和要產生資料庫的名稱 這邊可以看到要佈署的封裝檔案的版本。 若是第一次進行封裝佈署，基本上只要不斷按下一步就可以。而若是在開發專案中有遇到資料庫更新部分，也可以透過封裝檔案進行 把某一個資料表的ID設定為識別碼並且把封裝版本號修改一下然後，透過SSMS的更新資料應用程式，進行資料庫物件的更新 當然，還是需要選擇新版本的封裝檔案 基本上若是資料庫的資料表內有資料，都會跳出警告訊息，這部分主要是告知這些異動會動到資料表，有可能會有資料表內的資料遺失風險下圖也是進行相同的提示，這邊若是不須勾選確認會資料遺失的按鈕，就無法繼續下一步了 按完之後就等他進行更新了更新完畢後，就可以看到ID已經被設定成識別碼了。 以上透過這樣方式就可以佈署資料庫，同時也可以將資料庫設計納入版控中。但是，個人覺得在第一次進行資料庫佈署時候，透過封裝檔案方式進行佈署，算是非常方便的，且相關機制都可以透過Visual Studio進行管控與紀錄。若是，當我們有針對資料庫內資料表或是相關程式更新時候，尤其是資料表部分，還是建議乖乖去資料表內透過手動或是寫好Script方式進行更新資料表以免真的有資料遺失。雖然，可以備份資料，但是，若是資料表內資料非常的多時候，有時候遺失那些資料還真的找不出來，又要做資料比對又很花時間與精神，而針對原本預存程序或是檢視表的更新，就可以透過封裝檔案進行","categories":[{"name":"資料庫程式版控","slug":"資料庫程式版控","permalink":"http://edwardkuo.github.io/categories/資料庫程式版控/"}],"tags":[{"name":"T-SQL","slug":"T-SQL","permalink":"http://edwardkuo.github.io/tags/T-SQL/"}]},{"title":"ASP.NET 強制設定開啟或是關閉相容性檢視","slug":"Web/2016-06-10","date":"2016-06-09T14:59:31.000Z","updated":"2016-06-10T14:29:52.000Z","comments":true,"path":"paper/2016/06/09/Web/2016-06-10/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/09/Web/2016-06-10/","excerpt":"","text":"通常網頁在開發上，最怕就是整個版型跑掉，因為，網頁系統上的UI版型跑掉是最麻煩一件事情，但是往往因為，目前網頁開發技術並未統一，且又有可能有舊版的系統在使用。因此，IE上面會有相容性檢視的功能讓新版IE可以再使用舊版的系統(大都是IE8年代以前開發的系統)的版型不會跑掉。 在企業內部一般來說，因為很多年代久遠系統，所以，可能預設會把相容性檢視打該，但是，若是今天自己開發網站是用像是HTML5 + CSS3開發可能這樣版型在設定相容性模式下就會跑掉，但是，不太大可能讓使用者取消這設定，畢竟除新系統之外，還有成千上萬就系統還是要能執行。因此，我們可以在Web.config加入下面這一段，關閉相容性檢視這網站。或是開啟相容性檢視這網站 關閉相容性檢視 12345678&lt;system.webServer&gt; &lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;clear /&gt; &lt;add name=&quot;X-UA-Compatible&quot; value=&quot;IE=Edge&quot; /&gt; &lt;/customHeaders&gt; &lt;/httpProtocol&gt;&lt;/system.webServer&gt; 開啟相容性檢視 12345678&lt;system.webServer&gt; &lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;clear /&gt; &lt;add name=&quot;X-UA-Compatible&quot; value=&quot;IE=EmulateIE7&quot; /&gt; &lt;/customHeaders&gt; &lt;/httpProtocol&gt;&lt;/system.webServer&gt; 以上兩段就可以透過自己系統定義IE瀏覽器要不要開關相容性檢視了","categories":[],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://edwardkuo.github.io/tags/ASP-NET/"}]},{"title":"Azure Web App Inbound IP和Outbound IP的不同","slug":"Azure/2016-06-10","date":"2016-06-06T12:09:34.000Z","updated":"2016-06-10T14:32:23.000Z","comments":true,"path":"paper/2016/06/06/Azure/2016-06-10/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/06/Azure/2016-06-10/","excerpt":"","text":"Azure Web App有分為兩種類型的IP位址，一種是Inbound IP，一種是Outbound IP Inbound IP是所謂內部虛擬IP，一般你沒有綁定SSL憑證時，這個IP是與大家分享的 Outbound IP是對外的實體IP，這個IP取決於資料中心的配置，通常是四個IP輪詢 Inbound ＆ Outbound最簡單識別方式就是 A Web Site Call B Web Site 時，在B Web Site看到呼叫端的A Web Site IP就是屬於A Web Site的Outbound IP，B Web Site則是用Inbound接收A Web Site的Request 通常我們是不需要去管Web Site Outbound IP，不過，在某些情境下為了去設定防火牆，讓我們的Azure Web App能呼叫企業內部的服務或是網站，就必須去知道Web Site Outbound IP，才有辦法設定防火牆通過 outbound IP List列出所有Azure資料中心的Outbound IP，不過，為了以防萬一這些資訊有所變更不在這列表中，還可以用另一種方式去找到Outbound IP，就是到Azure Portal中的Web App內去找 先找到該Web App，然後到它的屬性內的Outbound IP 就可以查看這Web Site的Outbound IP，通常是都會配四組Outbound IP給這個Web Site 如果不想要透過這種方式去查詢Outbound IP，也可以使用Azure Resource Explorer這個工具去查詢，Azure Resource Explorer的網址https://resources.azure.com，它是一個可以發現Azure服務API的一個Web工具，雖然並非所有Azure服務都有支援，使用ARE好處如下： 取得Azure 服務的API 取得API相關資訊 可以直接使用上面API，更新你服務的設定 這個工具目前尚在Preview階段，所以，部分功能還不完整。以目前要查Outbound IP為例，只要去找到你所屬的Web Site名稱，就可以在旁邊的Json資訊中找到outboundIpAddresses Key，然後就可以發現此Web Site的Outbound IP List如果，有用中國Azure的人，目前此工具還不支援，再加上又沒有新的Portal可以支援查詢，因此，列出北京與上海資料中心的Outbound IP給有需要的人 Scale Unit Name: BJB-001 （北京資料中心） Outbound IP Addresses 42.159.4.73 42.159.4.84 42.159.4.211 42.159.4.160 Scale Unit Name: SHA-001 （上海資料中心） Outbound IP Addresses 42.159.135.109 42.159.135.174 42.159.135.208 42.159.133.172","categories":[],"tags":[{"name":"Azure","slug":"Azure","permalink":"http://edwardkuo.github.io/tags/Azure/"}]},{"title":"建立Azure上海與香港資料中心Site to Site VPN","slug":"Azure/2016-06-10-1","date":"2016-06-02T14:59:31.000Z","updated":"2016-06-10T14:33:01.000Z","comments":true,"path":"paper/2016/06/02/Azure/2016-06-10-1/","link":"","permalink":"http://edwardkuo.github.io/paper/2016/06/02/Azure/2016-06-10-1/","excerpt":"","text":"如果有同時使用China Azure和Global Azure，遇到最麻煩的事情，就是怎樣把兩邊的資料做整合，一方面是兩邊的Azure功能性不一致，另一方面是因為中國長城關係，導致資料Sync不能透過一般HTTP解決，因此，為了解決這問題，只好建立一組Site to Site的VPN，解決雙方的Azure資料中心的溝通問題 先自行規劃上海資料中心和香港資料中心的網路IP分配12* 上海資料中心：10.1.0.0 /16，名稱：CN-NET* 香港資料中心：10.2.0.0 /16，名稱：HK-NET 開始設定Azure的虛擬網路吧，先設定CN-NET這部分 虛擬網路名稱取名為CN-NET 這邊選 設定網站間VPN 設定香港資料中心的虛擬網路資訊，名稱設定為HK-NET，名稱後續要跟設定香港資料中心的名稱一樣，位置空間的IP就設定IP:10.2.0.0 /16 VPN裝置的IP位址，可以先隨便設定一個，後面會改掉，但是，設定的IP不可以跟你後續香港或是上海資料中內的位址IP有重複，不然會發生錯誤 設定上海資料中心的虛擬網路的IP10.1.0.0 /16，然後再設定Subnet IP 10.1.1.0 /29，按下確定就可以 上海資料中心設定完成後，再來設定香港資料中心，幾乎步驟都相同，只有在設定的地方不一樣 這邊依舊選 設定網站間VPN 改設定上海資料中心的虛擬網路資訊，所以名稱設定為CN-NET，位址IP10.1.0.0 /16，這邊的VPN IP位址，也可以先隨便設定一個，同樣的不可以跟你後續香港或是上海資料中內的位址重複，不然會出現錯誤 設定香港資料中心的虛擬網路的IP10.2.0.0 /16，在設定Subnet IP 10.2.1.0 /29，按下確定就可以設定完成 兩邊資料中心都設定完成後，在兩邊設定畫面中，就會出現VNET組態檔，這時候我們要把這組態檔匯出來 下載出來的組態檔內容如下，我們後續會修改組態檔中的 VPNGatewayaddress 的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;NetworkConfiguration xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://schemas.microsoft.com/ServiceHosting/2011/07/NetworkConfiguration&quot;&gt; &lt;VirtualNetworkConfiguration&gt; &lt;Dns /&gt; &lt;LocalNetworkSites&gt; &lt;LocalNetworkSite name=&quot;HK-NET&quot;&gt; &lt;AddressSpace&gt; &lt;AddressPrefix&gt;10.2.0.0/16&lt;/AddressPrefix&gt; &lt;/AddressSpace&gt; &lt;VPNGatewayAddress&gt;2.2.2.2&lt;/VPNGatewayAddress&gt; &lt;/LocalNetworkSite&gt; &lt;LocalNetworkSite name=&quot;v-net-west&quot;&gt; &lt;AddressSpace&gt; &lt;AddressPrefix&gt;10.200.0.0/16&lt;/AddressPrefix&gt; &lt;/AddressSpace&gt; &lt;VPNGatewayAddress&gt;23.99.112.76&lt;/VPNGatewayAddress&gt; &lt;/LocalNetworkSite&gt; &lt;/LocalNetworkSites&gt; &lt;VirtualNetworkSites&gt; &lt;VirtualNetworkSite name=&quot;CN-NET&quot; Location=&quot;China East&quot;&gt; &lt;AddressSpace&gt; &lt;AddressPrefix&gt;10.1.0.0/16&lt;/AddressPrefix&gt; &lt;/AddressSpace&gt; &lt;Subnets&gt; &lt;Subnet name=&quot;Subnet-1&quot;&gt; &lt;AddressPrefix&gt;10.1.0.0/24&lt;/AddressPrefix&gt; &lt;/Subnet&gt; &lt;Subnet name=&quot;GatewaySubnet&quot;&gt; &lt;AddressPrefix&gt;10.1.1.0/29&lt;/AddressPrefix&gt; &lt;/Subnet&gt; &lt;/Subnets&gt; &lt;Gateway&gt; &lt;ConnectionsToLocalNetwork&gt; &lt;LocalNetworkSiteRef name=&quot;HK-NET&quot;&gt; &lt;Connection type=&quot;IPsec&quot; /&gt; &lt;/LocalNetworkSiteRef&gt; &lt;/ConnectionsToLocalNetwork&gt; &lt;/Gateway&gt; &lt;/VirtualNetworkSite&gt; &lt;VirtualNetworkSite name=&quot;v-net-china&quot; Location=&quot;China East&quot;&gt; &lt;AddressSpace&gt; &lt;AddressPrefix&gt;10.100.0.0/16&lt;/AddressPrefix&gt; &lt;/AddressSpace&gt; &lt;Subnets&gt; &lt;Subnet name=&quot;Subnet-1&quot;&gt; &lt;AddressPrefix&gt;10.100.0.0/24&lt;/AddressPrefix&gt; &lt;/Subnet&gt; &lt;Subnet name=&quot;GatewaySubnet&quot;&gt; &lt;AddressPrefix&gt;10.100.1.0/29&lt;/AddressPrefix&gt; &lt;/Subnet&gt; &lt;/Subnets&gt; &lt;Gateway&gt; &lt;ConnectionsToLocalNetwork&gt; &lt;LocalNetworkSiteRef name=&quot;v-net-west&quot;&gt; &lt;Connection type=&quot;IPsec&quot; /&gt; &lt;/LocalNetworkSiteRef&gt; &lt;/ConnectionsToLocalNetwork&gt; &lt;/Gateway&gt; &lt;/VirtualNetworkSite&gt; &lt;/VirtualNetworkSites&gt; &lt;/VirtualNetworkConfiguration&gt;&lt;/NetworkConfiguration&gt; 在兩處的Azure虛擬網路部分，建立閘道，選定 動態路由 建立閘道時間會比較長，可能要20多分鐘以上，路由建立好後，會出現下面樣子 再回到剛剛的組態檔案，從CN-NET得到的閘道IP，修改從HK-NET下載的組態檔中的VPNgetwayaddress的值，然後再到香港資料中心取得其閘道IP，再將這閘道IP，取代從CN-NET下載的組態檔案中的VPNgetwayaddress的值 都設定好之後，分別上傳組態檔案，上海組態檔上傳到上海資料中心，香港組態檔上傳到香港資料中心 上面會顯示有被更新的資訊，直接確認就可以 到了這一步，基本上在介面上的設定都完畢，剩下就必須透過Powershell去把這兩邊的資料中心連線串接起來 首先先設定上海資料中心部分，使用Powershell去取得中國的Azure帳號，其指令是 1Add-AzureAccount -Environment AzureChinaCloud 登入後，使用 1Select-AzureSubscription -SubscriptionId &quot;訂閱號碼“ 選定我們的訂閱戶，開始配置兩邊的共享金鑰，金鑰名稱可以自行輸入，但是，兩邊資料中心的金鑰要使用一樣，如果在上海資料中心，設定的VNetName就是CN-Net，LocalNetworkSiteName就是hk-Net 1Set-AzureVNetGatewaykey -VNetName CN-NET -LocalNetworkSiteName HK-NET –SharedKey 金鑰 設定香港的資料中心 1Set-AzureVNetGatewaykey -VNetName HK-NET -LocalNetworkSiteName CN-NET –SharedKey 金鑰 兩邊都設定成功後，請再等待幾分鐘，就可以看到這兩邊的VNET串接起來了 如果不確定，也可以透過Powershell指令去查看1Get-AzureVnetConnection –VnetName HK-NET 這樣中國與Global兩邊資料中心的虛擬網路就串起來了，最後提醒一下，是設定Site to Site，而不是Point to Site VPN唷","categories":[],"tags":[{"name":"Azure","slug":"Azure","permalink":"http://edwardkuo.github.io/tags/Azure/"}]}]}